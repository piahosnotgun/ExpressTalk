import { BsonDataCodec } from '../packet/bson-data-codec.js';
import '../packet/chat/kickout.js';
import '../packet/struct/chat.js';
import '../channel/channel-info.js';
import '../channel/meta.js';
import '../openlink/index.js';
import '../util/json-util.js';
import '../user/user-type.js';
import { PacketAssembler } from './packet-assembler.js';
import { LocoPacketCodec } from './loco-packet-codec.js';

class LocoSession {
    constructor(stream) {
        this._assembler = new PacketAssembler(BsonDataCodec);
        this._codec = new LocoPacketCodec(stream);
        this._nextPromise = null;
        this._packetBuffer = [];
        this._requestSet = new Set();
    }
    get stream() {
        return this._codec.stream;
    }
    _lastBufRes() {
        if (this._packetBuffer.length > 0)
            return this._packetBuffer[this._packetBuffer.length - 1];
    }
    async _readInner() {
        const read = await this._codec.read();
        if (!read)
            return false;
        const res = {
            id: read.header.id,
            push: !this._requestSet.has(read.header.id),
            method: read.header.method,
            data: this._assembler.deconstruct(read)
        };
        this._packetBuffer.push(res);
        return true;
    }
    _readQueued() {
        if (this._nextPromise)
            return this._nextPromise;
        this._nextPromise = this._readInner();
        this._nextPromise.finally(() => this._nextPromise = null);
        return this._nextPromise;
    }
    async read() {
        while (this._packetBuffer.length < 1 && await this._readQueued())
            ;
        const first = this._packetBuffer[0];
        if (first && first.push)
            this._packetBuffer.shift();
        return first;
    }
    async _readId(id) {
        if (this._requestSet.has(id))
            throw new Error(`Packet id collision #${id}`);
        this._requestSet.add(id);
        while (await this._readQueued()) {
            const read = this._lastBufRes();
            if (read && read.id === id && this._requestSet.has(id)) {
                this._requestSet.delete(id);
                this._packetBuffer.pop();
                return read;
            }
        }
    }
    listen() {
        return {
            [Symbol.asyncIterator]() {
                return this;
            },
            next: async () => {
                const next = await this.read();
                if (!next)
                    return { done: true, value: null };
                return { done: false, value: next };
            }
        };
    }
    async request(method, data) {
        const req = this._assembler.construct(method, data);
        await this._codec.write(req);
        const res = await this._readId(req.header.id);
        if (!res)
            throw new Error(`Session closed before response #${req.header.id}`);
        return res.data;
    }
}

export { LocoSession };
//# sourceMappingURL=request-session.js.map
