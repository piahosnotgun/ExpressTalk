import { ChannelInfo, NormalChannelInfo } from '../../../channel/channel-info.js';
import '../../../channel/meta.js';
import '../../../openlink/index.js';
import { structToChatlog } from './chat.js';
import { OpenChannelInfo } from '../../../openlink/open-channel-info.js';

function structToChannelInfo(struct) {
    var _a;
    const displayUserList = struct.displayMembers ? struct.displayMembers.map((userStruct) => {
        return {
            userId: userStruct.userId,
            nickname: userStruct.nickName,
            countryIso: userStruct.countryIso || '',
            profileURL: userStruct.profileImageUrl,
        };
    }) : [];
    const metaMap = {};
    (_a = struct.chatMetas) === null || _a === void 0 ? void 0 : _a.forEach((meta) => metaMap[meta.type] = { ...meta });
    const info = {
        channelId: struct.chatId,
        type: struct.type,
        activeUserCount: struct.activeMembersCount,
        newChatCount: struct.newMessageCount,
        newChatCountInvalid: struct.invalidNewMessageCount,
        lastChatLogId: struct.lastLogId,
        pushAlert: struct.pushAlert,
        lastSeenLogId: struct.lastSeenLogId,
        metaMap,
        displayUserList,
    };
    if (struct.lastChatLog) {
        info['lastChatLog'] = structToChatlog(struct.lastChatLog);
    }
    return info;
}
function structToNormalChannelInfo(struct) {
    return {
        ...structToChannelInfo(struct),
        joinTime: struct.joinedAtForNewMem,
    };
}
function structToOpenChannelInfo(struct) {
    return {
        ...structToChannelInfo(struct),
        linkId: struct.li,
        openToken: struct.otk,
        directChannel: struct.directChat,
    };
}
function dataStructToChannelInfo(channelData) {
    const commonInfo = {
        channelId: channelData.c,
        type: channelData.t,
        lastChatLogId: channelData.ll,
        activeUserCount: channelData.a,
        lastSeenLogId: channelData.s,
        newChatCount: channelData.n,
        pushAlert: channelData.p
    };
    if (channelData.l) {
        commonInfo['lastChatLog'] = structToChatlog(channelData.l);
    }
    if (channelData.i && channelData.k) {
        commonInfo['displayUserList'];
        const list = [];
        const len = channelData.i.length;
        for (let i = 0; i < len; i++) {
            list.push({ userId: channelData.i[i], nickname: channelData.k[i], profileURL: '' });
        }
    }
    return ChannelInfo.createPartial(commonInfo);
}
function dataStructToNormalChannelInfo(channelData) {
    return NormalChannelInfo.createPartial(dataStructToChannelInfo(channelData));
}
function dataStructToOpenChannelInfo(channelData) {
    return OpenChannelInfo.createPartial({
        ...dataStructToChannelInfo(channelData),
        linkId: channelData.li,
        openToken: channelData.otk
    });
}

export { dataStructToChannelInfo, dataStructToNormalChannelInfo, dataStructToOpenChannelInfo, structToChannelInfo, structToNormalChannelInfo, structToOpenChannelInfo };
//# sourceMappingURL=channel.js.map
