{"version":3,"file":"cipher.js","sources":["../../../../node_modules/node-forge/lib/cipher.js"],"sourcesContent":["/**\n * Cipher base API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nmodule.exports = forge.cipher = forge.cipher || {};\n\n// registered algorithms\nforge.cipher.algorithms = forge.cipher.algorithms || {};\n\n/**\n * Creates a cipher object that can be used to encrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */\nforge.cipher.createCipher = function(algorithm, key) {\n  var api = algorithm;\n  if(typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n    if(api) {\n      api = api();\n    }\n  }\n  if(!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  }\n\n  // assume block cipher\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: false\n  });\n};\n\n/**\n * Creates a decipher object that can be used to decrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */\nforge.cipher.createDecipher = function(algorithm, key) {\n  var api = algorithm;\n  if(typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n    if(api) {\n      api = api();\n    }\n  }\n  if(!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  }\n\n  // assume block cipher\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: true\n  });\n};\n\n/**\n * Registers an algorithm by name. If the name was already registered, the\n * algorithm API object will be overwritten.\n *\n * @param name the name of the algorithm.\n * @param algorithm the algorithm API object.\n */\nforge.cipher.registerAlgorithm = function(name, algorithm) {\n  name = name.toUpperCase();\n  forge.cipher.algorithms[name] = algorithm;\n};\n\n/**\n * Gets a registered algorithm by name.\n *\n * @param name the name of the algorithm.\n *\n * @return the algorithm, if found, null if not.\n */\nforge.cipher.getAlgorithm = function(name) {\n  name = name.toUpperCase();\n  if(name in forge.cipher.algorithms) {\n    return forge.cipher.algorithms[name];\n  }\n  return null;\n};\n\nvar BlockCipher = forge.cipher.BlockCipher = function(options) {\n  this.algorithm = options.algorithm;\n  this.mode = this.algorithm.mode;\n  this.blockSize = this.mode.blockSize;\n  this._finish = false;\n  this._input = null;\n  this.output = null;\n  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n  this._decrypt = options.decrypt;\n  this.algorithm.initialize(options);\n};\n\n/**\n * Starts or restarts the encryption or decryption process, whichever\n * was previously configured.\n *\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\n * 32-bit integers, then it must be 4 integers long.\n *\n * Note: an IV is not required or used in ECB mode.\n *\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\n * by NIST SP-800-38D but another length may be given.\n *\n * @param options the options to use:\n *          iv the initialization vector to use as a binary-encoded string of\n *            bytes, null to reuse the last ciphered block from a previous\n *            update() (this \"residue\" method is for legacy support only).\n *          additionalData additional authentication data as a binary-encoded\n *            string of bytes, for 'GCM' mode, (default: none).\n *          tagLength desired length of authentication tag, in bits, for\n *            'GCM' mode (0-128, default: 128).\n *          tag the authentication tag to check if decrypting, as a\n *             binary-encoded string of bytes.\n *          output the output the buffer to write to, null to create one.\n */\nBlockCipher.prototype.start = function(options) {\n  options = options || {};\n  var opts = {};\n  for(var key in options) {\n    opts[key] = options[key];\n  }\n  opts.decrypt = this._decrypt;\n  this._finish = false;\n  this._input = forge.util.createBuffer();\n  this.output = options.output || forge.util.createBuffer();\n  this.mode.start(opts);\n};\n\n/**\n * Updates the next block according to the cipher mode.\n *\n * @param input the buffer to read from.\n */\nBlockCipher.prototype.update = function(input) {\n  if(input) {\n    // input given, so empty it into the input buffer\n    this._input.putBuffer(input);\n  }\n\n  // do cipher operation until it needs more input and not finished\n  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&\n    !this._finish) {}\n\n  // free consumed memory from input buffer\n  this._input.compact();\n};\n\n/**\n * Finishes encrypting or decrypting.\n *\n * @param pad a padding function to use in CBC mode, null for default,\n *          signature(blockSize, buffer, decrypt).\n *\n * @return true if successful, false on error.\n */\nBlockCipher.prototype.finish = function(pad) {\n  // backwards-compatibility w/deprecated padding API\n  // Note: will overwrite padding functions even after another start() call\n  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\n    this.mode.pad = function(input) {\n      return pad(this.blockSize, input, false);\n    };\n    this.mode.unpad = function(output) {\n      return pad(this.blockSize, output, true);\n    };\n  }\n\n  // build options for padding and afterFinish functions\n  var options = {};\n  options.decrypt = this._decrypt;\n\n  // get # of bytes that won't fill a block\n  options.overflow = this._input.length() % this.blockSize;\n\n  if(!this._decrypt && this.mode.pad) {\n    if(!this.mode.pad(this._input, options)) {\n      return false;\n    }\n  }\n\n  // do final update\n  this._finish = true;\n  this.update();\n\n  if(this._decrypt && this.mode.unpad) {\n    if(!this.mode.unpad(this.output, options)) {\n      return false;\n    }\n  }\n\n  if(this.mode.afterFinish) {\n    if(!this.mode.afterFinish(this.output, options)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n"],"names":["require$$0"],"mappings":"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"}