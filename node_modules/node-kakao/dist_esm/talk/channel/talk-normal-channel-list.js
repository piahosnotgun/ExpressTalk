import { EventContext } from '../../event/event-context.js';
import { TypedEmitter } from '../../event/typed.js';
import { KnownDataStatusCode } from '../../request/index.js';
import { TalkNormalChannel } from './talk-normal-channel.js';
import { TalkChannelListHandler } from './talk-channel-handler.js';
import { TalkChannelManageSession } from './talk-channel-session.js';
import { updateChatList } from './common.js';

class TalkNormalChannelList extends TypedEmitter {
    constructor(_session, _loader, list) {
        super();
        this._session = _session;
        this._loader = _loader;
        this._handler = new TalkChannelListHandler(this, this, this);
        this._manageSession = new TalkChannelManageSession(_session);
        this._map = new Map();
        if (list.length > 0) {
            list.forEach((channel) => this._map.set(channel.channelId.toString(), channel));
        }
    }
    get size() {
        return this._map.size;
    }
    get(channelId) {
        const strId = channelId.toString();
        return this._map.get(strId);
    }
    all() {
        return this._map.values();
    }
    async addChannel(channel, lastUpdate) {
        const last = this.get(channel.channelId);
        if (last)
            return { success: true, status: KnownDataStatusCode.SUCCESS, result: last };
        const strId = channel.channelId.toString();
        const infoStoreRes = await this._loader.loadNormalChannelStore(channel, lastUpdate);
        const chatStoreRes = await this._loader.loadChatListStore(channel);
        const talkChannel = new TalkNormalChannel(channel, this._session, infoStoreRes.value, chatStoreRes.value);
        this._map.set(strId, talkChannel);
        if (infoStoreRes.shouldUpdate) {
            const res = await talkChannel.updateAll();
            if (!res.success)
                return res;
        }
        if (chatStoreRes.shouldUpdate) {
            await updateChatList(talkChannel);
        }
        return { success: true, status: KnownDataStatusCode.SUCCESS, result: talkChannel };
    }
    removeChannel(channel) {
        return this._map.delete(channel.channelId.toString());
    }
    async createChannel(template) {
        const res = await this._manageSession.createChannel(template);
        if (!res.success)
            return res;
        return this.addChannel(res.result);
    }
    async createMemoChannel() {
        const res = await this._manageSession.createMemoChannel();
        if (!res.success)
            return res;
        return this.addChannel(res.result);
    }
    async leaveChannel(channel, block) {
        const res = await this._manageSession.leaveChannel(channel, block);
        if (res.success) {
            this.removeChannel(channel);
        }
        return res;
    }
    pushReceived(method, data, parentCtx) {
        const ctx = new EventContext(this, parentCtx);
        for (const channel of this._map.values()) {
            channel.pushReceived(method, data, ctx);
        }
        this._handler.pushReceived(method, data, parentCtx);
    }
    static async initialize(talkChannelList, channelList = []) {
        talkChannelList._map.clear();
        await Promise.all(channelList.map((data) => talkChannelList.addChannel(data.channel, data.lastUpdate)));
        return talkChannelList;
    }
}

export { TalkNormalChannelList };
//# sourceMappingURL=talk-normal-channel-list.js.map
