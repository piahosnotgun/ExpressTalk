import { Long as bson_9 } from '../../node_modules/bson/dist/bson.browser.esm.js';
import { sha1 } from '../../node_modules/hash-wasm/dist/index.esm.js';
import { KnownDataStatusCode } from '../../request/index.js';

async function mediaTemplateToForm(template) {
    return {
        size: template.data.byteLength,
        checksum: await sha1(template.data),
        metadata: {
            name: template.name,
            width: template.width,
            height: template.height,
            ext: template.ext
        }
    };
}
async function sendMultiMedia(channelSession, type, templates) {
    const res = await channelSession.uploadMultiMedia(type, await Promise.all(templates.map(mediaTemplateToForm)));
    if (!res.success)
        return res;
    let i = 0;
    for await (const entryRes of res.result.entries) {
        if (!entryRes.success)
            return entryRes;
        const entry = entryRes.result;
        const data = templates[i].data;
        await entry.stream.write(data.subarray(Math.min(entry.offset, data.byteLength)));
        const finishRes = await entry.finish();
        if (!finishRes.success)
            return finishRes;
        i++;
    }
    return res.result.finish();
}
async function sendMedia(channelSession, type, template) {
    const res = await channelSession.uploadMedia(type, await mediaTemplateToForm(template));
    if (!res.success)
        return res;
    const data = template.data;
    await res.result.stream.write(data.subarray(Math.min(res.result.offset, data.byteLength)));
    return res.result.finish();
}
function initWatermark(updater, idList, watermarkList) {
    updater.clearWatermark();
    const userLen = idList.length;
    for (let i = 0; i < userLen; i++) {
        const userId = idList[i];
        const watermark = watermarkList[i];
        updater.updateWatermark(userId, watermark);
    }
}
async function initNormalUserList(session, userIdList) {
    const userList = userIdList.map(userId => {
        return { userId };
    });
    const infoList = [];
    const len = userList.length;
    for (let i = 0; i < len; i += 300) {
        const userRes = await session.getLatestUserInfo(...userList.slice(i, i + 300));
        if (!userRes.success)
            return userRes;
        infoList.push(...userRes.result);
    }
    return {
        success: true,
        status: KnownDataStatusCode.SUCCESS,
        result: infoList
    };
}
async function initOpenUserList(session, userIdList) {
    const userList = userIdList.map(userId => {
        return { userId };
    });
    const infoList = [];
    const len = userList.length;
    for (let i = 0; i < len; i += 300) {
        const userRes = await session.getLatestUserInfo(...userList.slice(i, i + 300));
        if (!userRes.success)
            return userRes;
        infoList.push(...userRes.result);
    }
    return {
        success: true,
        status: KnownDataStatusCode.SUCCESS,
        result: infoList
    };
}
async function updateChatList(channel) {
    const startChat = await channel.chatListStore.last();
    const lastChatlog = channel.info.lastChatLog;
    if (lastChatlog && (!startChat || startChat.logId.lessThan(lastChatlog.logId))) {
        const iter = channel.syncChatList(lastChatlog.logId, (startChat === null || startChat === void 0 ? void 0 : startChat.logId) || bson_9.ZERO);
        for (let next = await iter.next(); !next.done; next = await iter.next())
            ;
    }
}
class TalkMemoryChannelDataStore {
    constructor(_info, _userInfoMap = new Map(), _watermarkMap = new Map()) {
        this._info = _info;
        this._userInfoMap = _userInfoMap;
        this._watermarkMap = _watermarkMap;
    }
    get info() {
        return this._info;
    }
    get userCount() {
        return this._userInfoMap.size;
    }
    getUserInfo(user) {
        return this._userInfoMap.get(user.userId.toString());
    }
    getAllUserInfo() {
        return this._userInfoMap.values();
    }
    clearUserList() {
        this._userInfoMap.clear();
    }
    getReadCount(chat) {
        let count = 0;
        if (this.userCount >= 100)
            return 0;
        for (const [strId] of this._userInfoMap) {
            const watermark = this._watermarkMap.get(strId);
            if (!watermark || watermark && watermark.greaterThanOrEqual(chat.logId))
                count++;
        }
        return count;
    }
    getReaders(chat) {
        const list = [];
        if (this.userCount >= 100)
            return [];
        for (const [strId, userInfo] of this._userInfoMap) {
            const watermark = this._watermarkMap.get(strId);
            if (watermark && watermark.greaterThanOrEqual(chat.logId))
                list.push(userInfo);
        }
        return list;
    }
    updateInfo(info) {
        this._info = { ...this._info, ...info };
    }
    setInfo(info) {
        this._info = info;
    }
    updateUserInfo(user, info) {
        const strId = user.userId.toString();
        const lastInfo = this._userInfoMap.get(strId);
        this._userInfoMap.set(strId, { ...lastInfo, ...info });
    }
    removeUser(user) {
        const strId = user.userId.toString();
        const userInfoRes = this._userInfoMap.delete(strId);
        const watermarkRes = this._watermarkMap.delete(strId);
        return userInfoRes || watermarkRes;
    }
    updateWatermark(readerId, watermark) {
        this._watermarkMap.set(readerId.toString(), watermark);
    }
    clearWatermark() {
        this._watermarkMap.clear();
    }
}

export { TalkMemoryChannelDataStore, initNormalUserList, initOpenUserList, initWatermark, mediaTemplateToForm, sendMedia, sendMultiMedia, updateChatList };
//# sourceMappingURL=common.js.map
