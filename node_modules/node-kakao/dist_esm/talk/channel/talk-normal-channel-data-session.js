import { NormalChannelInfo } from '../../channel/channel-info.js';
import '../../channel/meta.js';
import '../../packet/struct/chat.js';
import '../../openlink/index.js';
import '../../util/json-util.js';
import { structToChannelUserInfo } from '../../packet/struct/wrap/user.js';
import { initWatermark, initNormalUserList } from './common.js';

class TalkNormalChannelDataSession {
    constructor(_clientUser, _channelSession, _store) {
        this._clientUser = _clientUser;
        this._channelSession = _channelSession;
        this._store = _store;
    }
    get clientUser() {
        return this._clientUser;
    }
    get store() {
        return this._store;
    }
    async inviteUsers(users) {
        const res = await this._channelSession.inviteUsers(users);
        if (res.success) {
            await this.getLatestUserInfo(...users);
        }
        return res;
    }
    async chatON() {
        const res = await this._channelSession.chatON();
        if (res.success) {
            const { result } = res;
            if (this._store.info.type !== result.t || this._store.info.lastChatLogId !== result.l) {
                this._store.updateInfo({ type: result.t, lastChatLogId: result.l });
            }
            if (result.a && result.w) {
                this._store.clearWatermark();
                initWatermark(this._store, result.a, result.w);
            }
            if (result.m) {
                this._store.clearUserList();
                const structList = result.m;
                for (const struct of structList) {
                    const wrapped = structToChannelUserInfo(struct);
                    this._store.updateUserInfo(wrapped, wrapped);
                }
            }
            else if (result.mi) {
                this._store.clearUserList();
                const userInitres = await initNormalUserList(this._channelSession, result.mi);
                if (!userInitres.success)
                    return userInitres;
                for (const info of userInitres.result) {
                    this._store.updateUserInfo(info, info);
                }
                const channelSession = this._channelSession;
                if (!this._store.getUserInfo(this._clientUser)) {
                    const clientRes = await channelSession.getLatestUserInfo(this._clientUser);
                    if (!clientRes.success)
                        return clientRes;
                    for (const user of clientRes.result) {
                        this._store.updateUserInfo(user, user);
                    }
                }
            }
        }
        return res;
    }
    async getLatestChannelInfo() {
        const infoRes = await this._channelSession.getLatestChannelInfo();
        if (infoRes.success) {
            this._store.setInfo(NormalChannelInfo.createPartial(infoRes.result));
        }
        return infoRes;
    }
    async getLatestUserInfo(...users) {
        const infoRes = await this._channelSession.getLatestUserInfo(...users);
        if (infoRes.success) {
            const result = infoRes.result;
            result.forEach((info) => this._store.updateUserInfo(info, info));
        }
        return infoRes;
    }
    async getAllLatestUserInfo() {
        const infoRes = await this._channelSession.getAllLatestUserInfo();
        if (infoRes.success) {
            infoRes.result.map((info) => this._store.updateUserInfo(info, info));
        }
        return infoRes;
    }
}

export { TalkNormalChannelDataSession };
//# sourceMappingURL=talk-normal-channel-data-session.js.map
