import '../../chat/attachment/post.js';
import { KnownChatType } from '../../chat/chat-type.js';
import { feedFromChat } from '../../chat/feed/chat-feed.js';
import { KnownFeedType } from '../../chat/feed/feed-type.js';
import '../../openlink/index.js';
import '../../packet/struct/chat.js';
import '../../channel/channel-info.js';
import '../../channel/meta.js';
import { structToChatlog } from '../../packet/struct/wrap/chat.js';
import { structToOpenLinkChannelUserInfo } from '../../packet/struct/wrap/user.js';
import { OpenChannelUserPerm } from '../../openlink/open-link-type.js';

class TalkOpenChannelHandler {
    constructor(_channel, _session, _emitter, _store, _chatListStore) {
        this._channel = _channel;
        this._session = _session;
        this._emitter = _emitter;
        this._store = _store;
        this._chatListStore = _chatListStore;
    }
    _callEvent(parentCtx, event, ...args) {
        this._emitter.emit(event, ...args);
        parentCtx.emit(event, ...args);
    }
    _hostHandoverHandler(memTData, parentCtx) {
        if (!this._channel.channelId.eq(memTData.c) && !this._channel.linkId.eq(memTData.li))
            return;
        const len = memTData.mids.length;
        for (let i = 0; i < len; i++) {
            const user = { userId: memTData.mids[i] };
            const perm = memTData.mts[i];
            if (!perm)
                continue;
            const lastInfo = this._store.getUserInfo(user);
            this._store.updateUserInfo(user, { perm });
            const info = this._store.getUserInfo(user);
            if (lastInfo && info) {
                if (perm === OpenChannelUserPerm.OWNER) {
                    const lastLink = this._store.info.openLink;
                    this._session.getLatestOpenLink().then((res) => {
                        if (!res.success)
                            return;
                        this._store.updateInfo({ openLink: res.result });
                        this._callEvent(parentCtx, 'host_handover', this._channel, lastLink || res.result, res.result);
                    });
                }
                this._callEvent(parentCtx, 'perm_changed', this._channel, lastInfo, info);
            }
        }
    }
    _profileChangedHandler(pfData, parentCtx) {
        if (pfData.c && !this._channel.channelId.eq(pfData.c) ||
            pfData.li && !this._channel.linkId.eq(pfData.li))
            return;
        const last = this._store.getUserInfo(pfData.olu);
        if (!last)
            return;
        const updated = structToOpenLinkChannelUserInfo(pfData.olu);
        this._store.updateUserInfo(last, updated);
        this._callEvent(parentCtx, 'profile_changed', this._channel, last, updated);
    }
    _msgHiddenHandler(data, parentCtx) {
        const struct = data['chatLog'];
        if (!this._channel.channelId.eq(struct.chatId))
            return;
        const chatLog = structToChatlog(struct);
        if (chatLog.type !== KnownChatType.FEED)
            return;
        const feed = feedFromChat(chatLog);
        if (feed.feedType !== KnownFeedType.OPENLINK_REWRITE_FEED)
            return;
        this._callEvent(parentCtx, 'message_hidden', chatLog, this._channel, feed);
        this._chatListStore.addChat(chatLog).then();
    }
    _chatEventHandler(syncEventData, parentCtx) {
        if (!this._channel.channelId.eq(syncEventData.c) && !this._channel.linkId.eq(syncEventData.li))
            return;
        const user = this._store.getUserInfo({ userId: syncEventData.authorId });
        if (!user)
            return;
        this._callEvent(parentCtx, 'chat_event', this._channel, user, syncEventData.et, syncEventData.ec, { logId: syncEventData.logId, type: syncEventData.t });
    }
    _channelLinkDeletedHandler(data, parentCtx) {
        if (!this._channel.linkId.eq(data['li']))
            return;
        const struct = data['chatLog'];
        const chatLog = structToChatlog(struct);
        if (chatLog.type !== KnownChatType.FEED)
            return;
        const feed = feedFromChat(chatLog);
        if (feed.feedType !== KnownFeedType.OPENLINK_DELETE_LINK)
            return;
        this._callEvent(parentCtx, 'channel_link_deleted', chatLog, this._channel, feed);
        this._chatListStore.addChat(chatLog).then();
    }
    _userJoinHandler(data, parentCtx) {
        const struct = data['chatLog'];
        if (!this._channel.channelId.eq(struct.chatId))
            return;
        const chatLog = structToChatlog(struct);
        if (chatLog.type === KnownChatType.FEED) {
            const feed = feedFromChat(chatLog);
            let userList;
            if ('member' in feed) {
                userList = [feed.member];
            }
            else if ('members' in feed) {
                userList = feed.members;
            }
            else {
                userList = [];
            }
            this._session.getLatestUserInfo(...userList).then((usersRes) => {
                if (!usersRes.success)
                    return;
                for (const user of usersRes.result) {
                    this._store.updateUserInfo(user, user);
                    this._callEvent(parentCtx, 'user_join', chatLog, this._channel, user, feed);
                }
            });
        }
        this._chatListStore.addChat(chatLog).then();
    }
    pushReceived(method, data, parentCtx) {
        switch (method) {
            case 'SYNCMEMT':
                this._hostHandoverHandler(data, parentCtx);
                break;
            case 'SYNCLINKPF':
                this._profileChangedHandler(data, parentCtx);
                break;
            case 'SYNCREWR':
                this._msgHiddenHandler(data, parentCtx);
                break;
            case 'SYNCEVENT':
                this._chatEventHandler(data, parentCtx);
                break;
            case 'NEWMEM':
                this._userJoinHandler(data, parentCtx);
                break;
            case 'LNKDELETED':
                this._channelLinkDeletedHandler(data, parentCtx);
                break;
        }
    }
}
class TalkOpenChannelListHandler {
    constructor(_list, _emitter, _updater) {
        this._list = _list;
        this._emitter = _emitter;
        this._updater = _updater;
    }
    _callEvent(parentCtx, event, ...args) {
        this._emitter.emit(event, ...args);
        parentCtx.emit(event, ...args);
    }
    pushReceived(method, data, parentCtx) {
        switch (method) {
            case 'SYNCLINKCR': {
                const chatRoom = data['chatRoom'];
                if (!chatRoom)
                    break;
                this._updater.addChannel({ channelId: chatRoom.chatId }).then((channelRes) => {
                    if (!channelRes.success)
                        return;
                    this._callEvent(parentCtx, 'channel_join', channelRes.result);
                });
                break;
            }
            case 'LINKKICKED': {
                const kickData = data;
                const kickedChannel = this._list.get(kickData.c);
                if (!kickedChannel)
                    return;
                const chatLog = structToChatlog(kickData.chatLog);
                if (chatLog.type !== KnownChatType.FEED)
                    return;
                const feed = feedFromChat(chatLog);
                if (feed.feedType !== KnownFeedType.OPENLINK_KICKED)
                    return;
                this._callEvent(parentCtx, 'channel_kicked', chatLog, kickedChannel, feed);
                break;
            }
            case 'SYNCLINKDL': {
                const linkId = data['li'];
                const channel = (() => {
                    for (const channel of this._list.all()) {
                        if (channel.linkId.eq(linkId))
                            return channel;
                    }
                })();
                if (!channel)
                    return;
                this._updater.removeChannel(channel);
                this._callEvent(parentCtx, 'channel_left', channel);
            }
        }
    }
}

export { TalkOpenChannelHandler, TalkOpenChannelListHandler };
//# sourceMappingURL=talk-open-channel-handler.js.map
