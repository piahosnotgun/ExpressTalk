import '../../openlink/index.js';
import { KnownDataStatusCode } from '../../request/index.js';
import '../../packet/struct/chat.js';
import { structToOpenChannelInfo } from '../../packet/struct/wrap/channel.js';
import '../../util/json-util.js';
import { structToOpenChannelUserInfo, structToOpenLinkChannelUserInfo } from '../../packet/struct/wrap/user.js';
import { TalkOpenLinkSession } from './talk-open-link-session.js';
import '../../node_modules/bson/dist/bson.browser.esm.js';
import '../../node_modules/hash-wasm/dist/index.esm.js';
import '../../chat/attachment/post.js';
import '../../chat/chat-type.js';
import '../../chat/feed/feed-type.js';
import { TalkChannelManageSession } from '../channel/talk-channel-session.js';
import { TalkNormalChannelSession } from '../channel/talk-normal-channel-session.js';
import '../../node_modules/eventemitter3/index.js';
import '../../channel/meta.js';
import '../../channel/channel-info.js';
import { OpenChannelUserPerm } from '../../openlink/open-link-type.js';
import { OpenLinkProfile } from '../../openlink/open-link-profile.js';

class TalkOpenChannelSession {
    constructor(channel, session) {
        this._channel = channel;
        this._session = session;
        this._normalSession = new TalkNormalChannelSession(channel, session);
        this._linkSession = new TalkOpenLinkSession(session);
    }
    get session() {
        return this._session;
    }
    chatON() {
        return this._normalSession.chatON();
    }
    async markRead(chat) {
        const status = (await this._session.request('NOTIREAD', {
            'chatId': this._channel.channelId,
            'li': this._channel.linkId,
            'watermark': chat.logId,
        })).status;
        return {
            success: status === KnownDataStatusCode.SUCCESS,
            status,
        };
    }
    async getLatestChannelInfo() {
        const res = await this._session.request('CHATINFO', {
            'chatId': this._channel.channelId,
        });
        if (res.status !== KnownDataStatusCode.SUCCESS) {
            return { success: false, status: res.status };
        }
        return {
            success: true,
            status: res.status,
            result: structToOpenChannelInfo(res.chatInfo),
        };
    }
    async getLatestUserInfo(...channelUsers) {
        const res = await this._session.request('MEMBER', {
            'chatId': this._channel.channelId,
            'memberIds': channelUsers.map((user) => user.userId),
        });
        if (res.status !== KnownDataStatusCode.SUCCESS) {
            return { success: false, status: res.status };
        }
        const result = res.members.map((member) => structToOpenChannelUserInfo(member));
        return { status: res.status, success: true, result };
    }
    async getAllLatestUserInfo() {
        const res = await this._session.request('GETMEM', {
            'chatId': this._channel.channelId,
        });
        if (res.status !== KnownDataStatusCode.SUCCESS) {
            return { success: false, status: res.status };
        }
        const result = res.members.map((member) => structToOpenChannelUserInfo(member));
        return { status: res.status, success: true, result };
    }
    getKickList() {
        return this._linkSession.getKickList(this._channel);
    }
    removeKicked(user) {
        return this._linkSession.removeKicked(this._channel, { ...user, kickedChannelId: this._channel.channelId });
    }
    react(flag) {
        return this._linkSession.react(this._channel, flag);
    }
    getReaction() {
        return this._linkSession.getReaction(this._channel);
    }
    async getLatestOpenLink() {
        const res = await this._linkSession.getOpenLink(this._channel);
        if (res.success) {
            return { success: true, status: res.status, result: res.result[0] };
        }
        else {
            return res;
        }
    }
    async setUserPerm(user, perm) {
        const res = await this._session.request('SETMEMTYPE', {
            'c': this._channel.channelId,
            'li': this._channel.linkId,
            'mids': [user.userId],
            'mts': [perm],
        });
        return { status: res.status, success: res.status === KnownDataStatusCode.SUCCESS };
    }
    async createEvent(chat, type, count) {
        const res = await this._session.request('RELAYEVENT', {
            'c': this._channel.channelId,
            'li': this._channel.linkId,
            'et': type,
            'ec': count,
            'logId': chat.logId,
            't': chat.type,
        });
        return { status: res.status, success: res.status === KnownDataStatusCode.SUCCESS };
    }
    async handoverHost(user) {
        const res = await this._session.request('SETMEMTYPE', {
            'c': this._channel.channelId,
            'li': this._channel.linkId,
            'mids': [user.userId, this._session.clientUser.userId],
            'mts': [OpenChannelUserPerm.OWNER, OpenChannelUserPerm.NONE],
        });
        return { status: res.status, success: res.status === KnownDataStatusCode.SUCCESS };
    }
    async kickUser(user) {
        const res = await this._session.request('KICKMEM', {
            'c': this._channel.channelId,
            'li': this._channel.linkId,
            'mid': user.userId,
        });
        return { status: res.status, success: res.status === KnownDataStatusCode.SUCCESS };
    }
    async blockUser(user) {
        const res = await this._session.request('BLIND', {
            'c': this._channel.channelId,
            'li': this._channel.linkId,
            'mid': user.userId,
            'r': false,
        });
        return { status: res.status, success: res.status === KnownDataStatusCode.SUCCESS };
    }
    async changeProfile(profile) {
        const res = await this._session.request('UPLINKPROF', {
            'li': this._channel.linkId,
            ...OpenLinkProfile.serializeLinkProfile(profile),
        });
        if (res.status !== KnownDataStatusCode.SUCCESS)
            return { status: res.status, success: false };
        if (res['olu']) {
            return {
                status: res.status,
                success: true,
                result: structToOpenLinkChannelUserInfo(res['olu']),
            };
        }
        return { status: res.status, success: true, result: null };
    }
    async hideChat(chat) {
        const res = await this._session.request('REWRITE', {
            'li': this._channel.linkId,
            'c': this._channel.channelId,
            'logId': chat.logId,
            't': chat.type,
        });
        return { status: res.status, success: res.status === KnownDataStatusCode.SUCCESS };
    }
}
class TalkOpenChannelManageSession {
    constructor(_session) {
        this._session = _session;
        this._normalSession = new TalkChannelManageSession(_session);
    }
    leaveChannel(channel) {
        return this._normalSession.leaveChannel(channel);
    }
    async leaveKicked(channel) {
        const res = await this._session.request('KICKLEAVE', {
            'c': channel.channelId,
            'li': channel.linkId,
        });
        return { status: res.status, success: res.status === KnownDataStatusCode.SUCCESS };
    }
    async joinChannel(link, profile, passcode) {
        let token;
        if (passcode) {
            const tokenRes = await this._session.request('CHECKJOIN', {
                'li': link.linkId,
                'pc': passcode,
            });
            if (tokenRes.status !== KnownDataStatusCode.SUCCESS)
                return { status: tokenRes.status, success: false };
            token = tokenRes['tk'];
        }
        const reqData = {
            'li': link.linkId,
            'ref': 'EW:',
            ...OpenLinkProfile.serializeLinkProfile(profile),
        };
        if (token)
            reqData['tk'] = token;
        const res = await this._session.request('JOINLINK', reqData);
        if (res.status !== KnownDataStatusCode.SUCCESS)
            return { status: res.status, success: false };
        return { status: res.status, success: true, result: { channelId: res.chatRoom.chatId, linkId: res.ol.li } };
    }
}

export { TalkOpenChannelManageSession, TalkOpenChannelSession };
//# sourceMappingURL=talk-open-channel-session.js.map
