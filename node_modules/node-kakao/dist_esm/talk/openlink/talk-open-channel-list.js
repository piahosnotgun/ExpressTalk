import { Long as bson_9 } from '../../node_modules/bson/dist/bson.browser.esm.js';
import { EventContext } from '../../event/event-context.js';
import { TypedEmitter } from '../../event/typed.js';
import { KnownDataStatusCode } from '../../request/index.js';
import { updateChatList } from '../channel/common.js';
import { TalkChannelListHandler } from '../channel/talk-channel-handler.js';
import '../../chat/attachment/post.js';
import '../../chat/chat-type.js';
import '../../util/json-util.js';
import '../../chat/feed/feed-type.js';
import '../../packet/struct/chat.js';
import '../../channel/channel-info.js';
import '../../channel/meta.js';
import '../../openlink/index.js';
import '../../user/user-type.js';
import '../../stream/index.js';
import 'buffer';
import '../../packet/chat/kickout.js';
import { TalkOpenChannel } from './talk-open-channel.js';
import { TalkOpenChannelListHandler } from './talk-open-channel-handler.js';
import { TalkOpenChannelManageSession } from './talk-open-channel-session.js';
import { TalkClientLinkStore } from './client-link-store.js';

class TalkOpenChannelList extends TypedEmitter {
    constructor(_session, _loader, list, clientLinkList) {
        super();
        this._session = _session;
        this._loader = _loader;
        this._manageSession = new TalkOpenChannelManageSession(_session);
        this._handler = new TalkChannelListHandler(this, this, this);
        this._openHandler = new TalkOpenChannelListHandler(this, this, this);
        this._linkStore = new TalkClientLinkStore(_session, clientLinkList);
        this._map = new Map();
        if (list.length > 0) {
            list.forEach((channel) => this._map.set(channel.channelId.toString(), channel));
        }
    }
    get linkService() {
        return this._linkStore;
    }
    addClientLink(link) {
        this._linkStore.addClientLink(link);
    }
    deleteClientLink(linkId) {
        return this._linkStore.deleteClientLink(linkId);
    }
    removeChannel(channel) {
        return this._map.delete(channel.channelId.toString());
    }
    async addChannel(channel) {
        return this.addOpenChannel({ ...channel, linkId: bson_9.ZERO });
    }
    get(channelId) {
        return this._map.get(channelId.toString());
    }
    getChannelByLinkId(linkId) {
        for (const channel of this.all()) {
            if (channel.linkId.eq(linkId))
                return channel;
        }
    }
    getLinkChannelList(linkId) {
        const list = [];
        for (const channel of this.all()) {
            if (channel.linkId.eq(linkId))
                list.push(channel);
        }
        return list;
    }
    get size() {
        return this._map.size;
    }
    all() {
        return this._map.values();
    }
    allClientLink() {
        return this._linkStore.allClientLink();
    }
    getClientLink(linkId) {
        return this._linkStore.getClientLink(linkId);
    }
    get clientLinkCount() {
        return this._linkStore.clientLinkCount;
    }
    async addOpenChannel(channel, lastUpdate) {
        const last = this.get(channel.channelId);
        if (last)
            return { success: true, status: KnownDataStatusCode.SUCCESS, result: last };
        const infoStoreRes = await this._loader.loadOpenChannelStore(channel, lastUpdate);
        const chatStoreRes = await this._loader.loadChatListStore(channel);
        const talkChannel = new TalkOpenChannel(channel, this._session, infoStoreRes.value, chatStoreRes.value);
        this._map.set(channel.channelId.toString(), talkChannel);
        if (infoStoreRes.shouldUpdate) {
            const res = await talkChannel.updateAll();
            if (!res.success)
                return res;
        }
        if (chatStoreRes.shouldUpdate) {
            await updateChatList(talkChannel);
        }
        return { success: true, status: KnownDataStatusCode.SUCCESS, result: talkChannel };
    }
    async leaveKicked(channel) {
        const res = await this._manageSession.leaveKicked(channel);
        if (res.success) {
            this._map.delete(channel.channelId.toString());
        }
        return res;
    }
    async leaveChannel(channel) {
        const res = await this._manageSession.leaveChannel(channel);
        if (res.success) {
            this._map.delete(channel.channelId.toString());
        }
        return res;
    }
    getLatestLinkList() {
        return this._linkStore.getLatestLinkList();
    }
    getOpenLink(...components) {
        return this._linkStore.getOpenLink(...components);
    }
    getJoinInfo(linkURL, referer) {
        return this._linkStore.getJoinInfo(linkURL, referer);
    }
    getKickList(link) {
        return this._linkStore.getKickList(link);
    }
    removeKicked(link, kickedUser) {
        return this._linkStore.removeKicked(link, kickedUser);
    }
    async deleteLink(link) {
        const res = await this._linkStore.deleteLink(link);
        if (res.success) {
            this._linkStore.deleteClientLink(link.linkId);
            for (const channel of this.getLinkChannelList(link.linkId)) {
                this.removeChannel(channel);
            }
        }
        return res;
    }
    react(link, flag) {
        return this._linkStore.react(link, flag);
    }
    getReaction(link) {
        return this._linkStore.getReaction(link);
    }
    async createOpenChannel(template, profile) {
        const res = await this._linkStore.createOpenChannel(template, profile);
        if (!res.success)
            return res;
        return this.addOpenChannel(res.result);
    }
    createOpenDirectProfile(template, profile) {
        return this._linkStore.createOpenDirectProfile(template, profile);
    }
    createOpenProfile(template) {
        return this._linkStore.createOpenProfile(template);
    }
    updateOpenLink(link, settings) {
        return this._linkStore.updateOpenLink(link, settings);
    }
    pushReceived(method, data, parentCtx) {
        const ctx = new EventContext(this, parentCtx);
        for (const channel of this._map.values()) {
            channel.pushReceived(method, data, ctx);
        }
        this._handler.pushReceived(method, data, parentCtx);
        this._openHandler.pushReceived(method, data, parentCtx);
        this._linkStore.pushReceived(method, data, parentCtx);
    }
    async joinChannel(link, profile, passcode) {
        const res = await this._manageSession.joinChannel(link, profile, passcode);
        if (!res.success)
            return res;
        return this.addOpenChannel(res.result);
    }
    static async initialize(talkChannelList, channelList = []) {
        talkChannelList._map.clear();
        await Promise.all(channelList.map((data) => talkChannelList.addOpenChannel(data.channel, data.lastUpdate)));
        await talkChannelList._linkStore.getLatestLinkList();
        return talkChannelList;
    }
}

export { TalkOpenChannelList };
//# sourceMappingURL=talk-open-channel-list.js.map
