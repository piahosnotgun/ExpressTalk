import { DefaultConfiguration } from '../../config.js';
import { TalkSessionFactory } from '../network/index.js';
import { TalkClientSession } from './talk-client-session.js';
export { TalkClientSession } from './talk-client-session.js';
import { EventContext } from '../../event/event-context.js';
import { TypedEmitter } from '../../event/typed.js';
import { TalkChannelList } from '../talk-channel-list.js';
import { Long as bson_9 } from '../../node_modules/bson/dist/bson.browser.esm.js';
import { TalkBlockSession } from '../block/index.js';
import { TalkInMemoryDataLoader } from '../loader.js';

class TalkClient extends TypedEmitter {
    constructor(config = {}, loader = TalkInMemoryDataLoader, _sessionFactory = new TalkSessionFactory()) {
        super();
        this._sessionFactory = _sessionFactory;
        this.pingInterval = 60000;
        this._pingTask = null;
        this._session = null;
        this._clientSession = new TalkClientSession(this.createSessionProxy(), { ...DefaultConfiguration, ...config });
        this._channelList = new TalkChannelList(this.createSessionProxy(), loader);
        this._clientUser = { userId: bson_9.ZERO };
        this._blockList = new TalkBlockSession(this.createSessionProxy());
    }
    get configuration() {
        return this._clientSession.configuration;
    }
    set configuration(configuration) {
        this._clientSession.configuration = configuration;
    }
    get channelList() {
        return this._channelList;
    }
    get clientUser() {
        if (!this.logon)
            throw new Error('Cannot access without logging in');
        return this._clientUser;
    }
    get blockList() {
        return this._blockList;
    }
    get logon() {
        return this._session != null;
    }
    get session() {
        if (this._session == null)
            throw new Error('Session is not created');
        return this._session;
    }
    async login(credential) {
        if (this.logon)
            this.close();
        const sessionRes = await this._sessionFactory.connect(credential.userId, this.configuration);
        if (!sessionRes.success)
            return sessionRes;
        this._session = sessionRes.result;
        const loginRes = await this._clientSession.login(credential);
        if (!loginRes.success)
            return loginRes;
        this._clientUser = { userId: loginRes.result.userId };
        await TalkChannelList.initialize(this._channelList, loginRes.result.channelList);
        this.addPingHandler();
        this.listen();
        return { status: loginRes.status, success: true, result: loginRes.result };
    }
    setStatus(status) {
        return this._clientSession.setStatus(status);
    }
    getTokens(unknown) {
        return this._clientSession.getTokens(unknown);
    }
    isClientUser(user) {
        return this._clientUser.userId.equals(user.userId);
    }
    close() {
        if (!this.session.stream.ended) {
            this.session.stream.close();
        }
    }
    pushReceived(method, data, ctx) {
        this._channelList.pushReceived(method, data, ctx);
        switch (method) {
            case 'KICKOUT': {
                super.emit('disconnected', data.reason);
                this.close();
                break;
            }
            case 'CHANGESVR': {
                super.emit('switch_server');
                break;
            }
        }
        super.emit('push_packet', method, data);
    }
    createSessionProxy() {
        const instance = this;
        return {
            request: (method, data) => this.request(method, data),
            get clientUser() {
                return instance.clientUser;
            },
            get configuration() {
                return instance.configuration;
            },
        };
    }
    request(method, data) {
        return this.session.request(method, data);
    }
    listenEnd() {
        if (this._session)
            this._session = null;
        if (this._pingTask) {
            clearTimeout(this._pingTask);
        }
    }
    onError(err) {
        super.emit('error', err);
        if (this.listeners('error').length > 0 && !this.session.stream.ended) {
            this.listen();
        }
        else {
            this.close();
        }
    }
    listen() {
        (async () => {
            for await (const { method, data, push } of this.session.listen()) {
                if (push) {
                    try {
                        this.pushReceived(method, data, new EventContext(this));
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        })().then(this.listenEnd.bind(this)).catch(this.onError.bind(this));
    }
    addPingHandler() {
        const pingHandler = () => {
            if (!this.logon)
                return;
            this.session.request('PING', {});
            this._pingTask = setTimeout(pingHandler, this.pingInterval);
        };
        pingHandler();
    }
}

export { TalkClient };
//# sourceMappingURL=index.js.map
